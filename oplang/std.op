(global @OP_VERSION "a0.1")
(global @if (func-inline @:cond @:case @:else
    #(do ((bool :cond) :case :else))))

(global @not (func @v
    #((bool v) false true)))
(global @or (func @a @b
    #((bool a) true
      ((bool b) true false)
    )
))
(global @and (func @a @b
    #((bool a)
        ((bool b) true false)
        false
    )
))

(global @number? (func @v
    #(= (type v) "number")
))
(global @bool? (func @v
    #(= (type v) "boolean")
))
(global @string? (func @v
    #(= (type v) "string")
))
(global @table? (func @v
    #(= (type v) "table")
))
(global @func? (func @v
    #(= (type v) "function")
))
(global @nil? (func @v
    #(= (type v) "nil")
))

(global @map (func @list @f #{
    (if (not (table? list))
        #(error (.. "bad argument #1 (expected table, got " (type list) ")"))
    )
    (if (not (func? f))
        #(error (.. "bad argument #2 (expected function, got " (type f) ")"))
    )
    (for @k @v list #(seti list k (f v)))
    list
}))
(global @reduce (func @f @list #{
    (if (not (table? list))
        #(error (.. "bad argument #1 (expected table, got " (type list) ")"))
    )
    (if (not (func? f))
        #(error (.. "bad argument #2 (expected function, got " (type f) ")"))
    )
    (set @res)
    (for @k @v list
        #(if (nil? res)
            #(set @res v)
            #(set @res (f res v))
        )
    )
    res
}))
(global @check (func @f @list #{
    (if (not (table? list))
        #(error (.. "bad argument #1 (expected table, got " (type list) ")"))
    )
    (if (not (func? f))
        #(error (.. "bad argument #2 (expected function, got " (type f) ")"))
    )
    (forn @i 1 (- (len list) 1)
        #(if (not (f (list i) (list (+ i 1))))
            false
        )
    )
    true
}))